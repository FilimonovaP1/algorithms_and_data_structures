# algorithms_and_data_structures
Анализ алгоритма: Сортировка выбором (Selection Sort)
Определение:
Сортировка выбором (Selection Sort) — это алгоритм сортировки, который на каждом шаге ищет наименьший элемент в неотсортированной части массива и помещает его на правильное место в начале.
Таким образом, массив постепенно делится на две части: отсортированную и оставшуюся неотсортированную.
Анализ:
Алгоритм последовательно проходит по массиву. Для каждой позиции определяется индекс минимального элемента в неотсортированной области, после чего элементы меняются местами.
Внешний цикл for выполняется n - 1 раз, так как после помещения последних двух элементов массив становится полностью отсортирован.
Внутренний цикл for проходит по оставшимся элементам, выполняясь в худшем случае n - 1, n - 2, ..., 1 раз.
Итоговое количество сравнений примерно равно n*(n-1)/2.
Количество обменов элементов не превышает n - 1.
Временная сложность: O(n²)
Обоснование:
Алгоритм использует два вложенных цикла, и общее число операций зависит от квадрата количества элементов.
Так как внутренний цикл выполняется почти n раз для каждой итерации внешнего, время работы растёт пропорционально n², независимо от того, отсортированы ли данные изначально.


Анализ алгоритма: Пузырьковая сортировка (Bubble Sort)
Определение:
Пузырьковая сортировка (Bubble Sort) — это алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены в неправильном порядке.
После каждого прохода самый большой элемент «всплывает» в конец массива, как пузырёк в воде, поэтому алгоритм и получил такое название.
Анализ:
Алгоритм выполняет несколько проходов по массиву. На каждом проходе соседние элементы сравниваются и при необходимости меняются местами, чтобы более крупные значения постепенно перемещались к концу списка.
Внешний цикл for выполняется n - 1 раз, где n — количество элементов в массиве.
Внутренний цикл for проходит по неотсортированной части массива, выполняя n - i - 1 сравнений за каждую итерацию внешнего цикла.
Для оптимизации используется флаг swapped, который позволяет завершить работу алгоритма раньше, если за проход не было выполнено ни одного обмена (массив уже отсортирован).
Количество сравнений в худшем случае составляет примерно n*(n-1)/2.
Количество обменов зависит от исходного порядка элементов и в худшем случае также пропорционально n².
Временная сложность: O(n²)
Почему O(n²):
В алгоритме используются два вложенных цикла, и количество сравнений растёт квадратично с увеличением размера входного массива.
Даже если часть массива уже отсортирована, в среднем и худшем случае внутренний цикл выполняется примерно n раз для каждой итерации внешнего цикла, что даёт квадратичную зависимость.


Анализ алгоритма: Сортировка вставками (Insertion Sort)
Определение:
Сортировка вставками (Insertion Sort) — это алгоритм, который формирует отсортированную часть массива постепенно.
На каждом шаге берётся один элемент из неотсортированной части и вставляется в нужное место в уже отсортированной части массива.
По сути, алгоритм работает так же, как человек раскладывает карты по возрастанию.
Анализ:
Алгоритм последовательно перебирает элементы массива, начиная со второго (так как первый элемент считается уже отсортированным).
Для каждого элемента key выполняется поиск позиции, в которую его нужно вставить. Элементы, которые больше key, сдвигаются вправо, чтобы освободить место.
Внешний цикл for выполняется n - 1 раз (от второго до последнего элемента).
Внутренний цикл while выполняется столько раз, сколько элементов нужно сдвинуть — в худшем случае это почти все элементы в отсортированной части.
Таким образом, общее количество сравнений и перестановок в худшем случае составляет около n*(n-1)/2.
Временная сложность: O(n²)
Почему O(n²):
В худшем случае (если массив изначально отсортирован в обратном порядке) каждый новый элемент сравнивается со всеми предыдущими, что даёт квадратичное время работы.
В среднем случае время также пропорционально n².
Однако в лучшем случае (если массив уже отсортирован) внутренний цикл почти не выполняется, и сложность снижается до O(n).


Анализ алгоритма: Сортировка слиянием (Merge Sort)
Определение:
Сортировка слиянием (Merge Sort) — это алгоритм, который использует принцип «разделяй и властвуй».
Он делит массив на две части, рекурсивно сортирует каждую из них, а затем объединяет отсортированные подмассивы в один общий отсортированный массив.
Анализ:
Алгоритм рекурсивно разделяет исходный массив на две половины до тех пор, пока не останутся отдельные элементы.
После этого выполняется слияние отсортированных подмассивов с помощью вспомогательной функции merge(), которая объединяет их в правильном порядке.
Каждый уровень рекурсии требует линейного количества операций (около n), а общее количество уровней деления пропорционально log₂n.
Таким образом, общее количество операций в среднем и худшем случае составляет n * log₂n.
Процесс сортировки не зависит от исходного порядка элементов — время выполнения остаётся одинаковым для любого входного массива.
Временная сложность: O(n log n)
Почему O(n log n):
На каждом уровне рекурсии выполняется объединение всех элементов массива (O(n)), а общее количество уровней деления — порядка log₂n.
Следовательно, итоговая временная сложность алгоритма равна O(n log n).

Анализ алгоритма: Сортировка Шелла (Shell Sort)
Определение:
Сортировка Шелла (Shell Sort) — это усовершенствованный вариант сортировки вставками.
Главная идея заключается в том, чтобы на ранних этапах сравнивать и переставлять элементы, находящиеся друг от друга на определённом расстоянии (шаге, gap).
Постепенно шаг уменьшается, и в конце алгоритм сводится к обычной сортировке вставками, но массив к этому моменту уже частично упорядочен.
Анализ:
Алгоритм начинает с большого значения шага (gap), обычно равного половине длины массива, и постепенно уменьшает его в два раза.
На каждом этапе выполняется модифицированная сортировка вставками, при которой сравниваются элементы, стоящие друг от друга на расстоянии gap.
По мере уменьшения шага массив становится всё более упорядоченным, и завершающий этап (при gap = 1) требует меньше перестановок, чем обычная сортировка вставками.
Количество итераций и сравнений зависит от выбранной последовательности шагов, поэтому точное количество операций варьируется.
В худшем случае количество операций может достигать O(n²), но при удачном выборе последовательности шагов (например, последовательность Шелла, Хиббарда или Кнута) время работы может быть ближе к O(n log² n).
Временная сложность: O(n²)
Почему O(n²):
В общем случае алгоритм выполняет несколько проходов по массиву с внутренними циклами, подобно сортировке вставками.
Хотя благодаря уменьшению шага сортировка выполняется быстрее, при неблагоприятных исходных данных или неудачной последовательности шагов асимптотическая сложность может оставаться квадратичной — O(n²).

Анализ алгоритма: Быстрая сортировка (Quick Sort)
Определение:
Быстрая сортировка (Quick Sort) — это алгоритм, основанный на принципе «разделяй и властвуй».
Он выбирает один элемент массива в качестве опорного (pivot) и переставляет остальные элементы так, чтобы все, что меньше pivot, оказались слева, а большие — справа.
Затем процесс повторяется рекурсивно для обеих частей массива, пока массив не будет полностью отсортирован.
Анализ:
Алгоритм начинает с выбора опорного элемента (в данном коде — последнего).
Затем выполняется функция partition(), которая проходит по массиву и распределяет элементы относительно pivot: меньшие помещаются слева, большие — справа.
После этого quickSort() рекурсивно вызывается для левой и правой частей массива, которые сортируются независимо.
Каждое разбиение массива требует линейного количества операций (O(n)), а количество уровней рекурсии в среднем составляет O(log n).
Таким образом, в среднем и лучшем случаях общее время работы равно O(n log n).
Однако при неудачном выборе опорного элемента (например, если массив уже отсортирован) глубина рекурсии увеличивается до n, и тогда сложность возрастает до O(n²).
Временная сложность: O(n log n)
Почему O(n log n):
На каждом уровне рекурсии происходит разбиение массива за линейное время (O(n)),
а общее количество уровней деления массива пропорционально log n.
Следовательно, средняя временная сложность алгоритма равна O(n log n),
хотя в худшем случае при неблагоприятном выборе опорного элемента она может достигать O(n²).


Анализ алгоритма: Пирамидальная сортировка (Heap Sort)
Определение:
Пирамидальная сортировка (Heap Sort) — это алгоритм сортировки, который основан на структуре данных бинарная куча (heap).
Сначала из элементов массива строится макс-куча (max-heap), в которой каждый родительский элемент больше своих потомков.
Затем максимальный элемент (корень кучи) последовательно перемещается в конец массива, а оставшаяся часть снова преобразуется в кучу.
Анализ:
Алгоритм работает в два основных этапа:
1.	Построение кучи — из исходного массива формируется max-heap. Этот процесс требует порядка O(n)операций.
2.	Извлечение элементов — максимальный элемент (корень) помещается в конец массива, а для оставшейся части массива снова вызывается функция heapify, которая восстанавливает свойство кучи.
Этот процесс повторяется n - 1 раз. Каждое восстановление кучи занимает O(log n) времени, так как высота дерева равна log n.
В сумме общее время работы алгоритма составляет O(n log n).
Количество сравнений и перестановок не зависит от исходного порядка элементов, поэтому алгоритм показывает стабильное время работы для любого входного массива.
Временная сложность: O(n log n)
Почему O(n log n):
Построение кучи выполняется за линейное время (O(n)), а затем происходит n извлечений, каждое из которых требует O(log n) шагов для восстановления структуры кучи.
В результате итоговая сложность равна O(n log n) как в среднем, так и в худшем случае.


Анализ алгоритма: Линейный поиск (Linear Search)
Определение:
Линейный поиск (Linear Search) — это простой алгоритм поиска элемента в списке.
Он последовательно перебирает все элементы массива и сравнивает каждый из них с искомым значением (target).
Если элемент найден, возвращается его индекс; если нет — функция возвращает -1.
Анализ:
Алгоритм проходит по списку с начала до конца, сравнивая каждый элемент с заданным значением.
Как только находится совпадение — поиск завершается, и возвращается индекс найденного элемента.
Если ни одно значение не совпадает с искомым, то по завершении цикла функция возвращает -1.
В лучшем случае элемент находится на первой позиции (выполняется одно сравнение).
В худшем случае требуется проверить все n элементов — либо потому что элемент находится в конце, либо потому что его вовсе нет в списке.
Таким образом, количество операций сравнения в худшем случае пропорционально количеству элементов n.
Временная сложность: O(n)
Почему O(n):
Алгоритм последовательно проверяет каждый элемент списка до тех пор, пока не найдёт нужный или не дойдёт до конца.
Количество операций линейно зависит от размера входных данных — чем больше элементов, тем больше сравнений, поэтому сложность равна O(n).

Анализ алгоритма: Бинарный поиск (Binary Search)
Определение:
Бинарный поиск — это эффективный алгоритм для нахождения элемента в отсортированном массиве.
Он делит массив пополам и определяет, в какой из половин может находиться искомое значение.
Затем поиск продолжается только в этой половине, снова деля её пополам, и так до тех пор, пока элемент не будет найден или диапазон поиска не станет пустым.
Анализ:
Алгоритм начинает с проверки среднего элемента массива.
Если этот элемент совпадает с искомым — поиск завершается.
Если значение в середине меньше нужного, то поиск продолжается в правой половине массива;
если больше — в левой.
Каждое сравнение сокращает диапазон поиска в два раза, благодаря чему число итераций растёт очень медленно даже при большом количестве элементов.
Если элемент не найден после того, как границы поиска пересеклись, функция возвращает -1.
Бинарный поиск требует, чтобы массив был предварительно отсортирован, иначе результаты будут некорректными.
Временная сложность: O(log n)
Почему O(log n):
На каждом шаге алгоритм делит область поиска пополам, уменьшая количество проверяемых элементов в 2 раза.
Таким образом, общее количество шагов пропорционально логарифму от размера массива по основанию 2 (log₂n).
Именно поэтому временная сложность бинарного поиска равна O(log n).


Анализ алгоритма: Интерполяционный поиск (Interpolation Search)
Определение:
Интерполяционный поиск — это усовершенствованный вариант бинарного поиска, применяемый для равномерно распределённых отсортированных массивов.
Вместо проверки середины диапазона он вычисляет предполагаемую позицию элемента на основе его значения относительно границ массива.
Анализ:
Алгоритм начинает с установки границ low и high.
Затем вычисляется предполагаемая позиция элемента pos по формуле интерполяции:
pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]).
Если элемент на позиции pos совпадает с искомым — поиск завершён.
Если arr[pos] < target, поиск продолжается в правой части массива;
если arr[pos] > target — в левой.
При равных значениях на границах выполняется отдельная проверка.
Если диапазон поиска становится недопустимым, функция возвращает -1.
Временная сложность:
•	Лучший случай: O(1)
•	Средний случай: O(log(log n))
•	Худший случай: O(n)
Почему O(log(log n)):
Алгоритм уменьшает диапазон поиска быстрее, чем бинарный, так как использует значения элементов для приближения к цели.
При равномерном распределении данных это даёт почти двукратное ускорение по сравнению с обычным бинарным поиском.

Анализ алгоритма: Поиск по Фибоначчи (Fibonacci Search)
Определение:
Поиск по Фибоначчи — это алгоритм поиска элемента в отсортированном массиве, который использует последовательность чисел Фибоначчи для деления диапазона поиска.
Он работает похожим образом на бинарный поиск, но определяет позицию для проверки с помощью чисел Фибоначчи.
Анализ:
Алгоритм начинает с вычисления минимального числа Фибоначчи, большего или равного длине массива.
Затем с помощью этих чисел он постепенно сужает диапазон поиска:
если значение меньше искомого — поиск продолжается справа, если больше — слева.
Каждое сравнение сокращает область поиска по принципу чисел Фибоначчи.
Если элемент найден — возвращается его индекс, если нет — результат равен -1.
Массив должен быть предварительно отсортирован.
Временная сложность: O(log n)
Почему O(log n):
На каждом шаге диапазон уменьшается в соответствии с отношением соседних чисел Фибоначчи, что приводит к логарифмической зависимости количества итераций от размера массива.

